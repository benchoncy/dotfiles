#!/usr/bin/env python3
# Inspired by tmux-sessionizer/tmux-windowizer
# Manages local git repos and git worktrees

import argparse
import os

# Environment variables
PROJECTS_SUFFIX = os.environ.get('GIT_WORKTREE_PROJECTS_SUFFIX', '.tree')
PROJECTS_PATH = os.environ.get(
    'GIT_WORKTREE_PROJECTS_PATH', os.path.expanduser('~/projects'))
BARE_FOLDER = os.environ.get(
    'GIT_WORKTREE_BARE_PATH', 'bare.git')


def add_worktree(project_path, branch_name):
    if not os.path.isdir(f'{project_path}/{branch_name}'):
        os.chdir(f'{project_path}/{BARE_FOLDER}')
        os.system(f'git worktree add ../{branch_name} &> /dev/null')
    # Output the path to the worktree
    print(f'{project_path}/{branch_name}')


def remove_worktree(project_path, branch_name):
    os.chdir(f'{project_path}/{BARE_FOLDER}')
    os.system(f'git worktree remove ../{branch_name} &> /dev/null')


def plant(args):
    # Check if the repo url is valid
    if not args.repo_url.endswith('.git'):
        print('Invalid git repo url:', args.repo_url)
        return

    # Check if the projects path is valid
    if not os.path.isdir(args.projects_path):
        print('Invalid projects path:', args.projects_path)
        return

    owner, repo_name = args.repo_url.replace(':', '/').split('/')[-2:]
    local_repo_name = f'{owner}-{repo_name}' \
        .replace('_', '-') \
        .replace('.git', PROJECTS_SUFFIX)

    # Checkout the repo as a bare repo
    os.chdir(args.projects_path)
    os.system(
        f'git clone --bare {args.repo_url} {local_repo_name}/{BARE_FOLDER}'
        ' &> /dev/null')

    # Create a worktree with the default branch name
    os.chdir(f'{args.projects_path}/{local_repo_name}/{BARE_FOLDER}')
    default_branch_name = os.popen('git branch --show-current').read().strip()
    add_worktree(
        f'{args.projects_path}/{local_repo_name}',
        default_branch_name)


def parent_dir():
    return os.path.abspath(os.path.join(os.getcwd(), os.pardir))


def worktree(args):
    # Check if the repo path is valid
    if not os.path.isdir(args.repo_path):
        print('Invalid git repo path:', args.repo_path)
        return

    # Check if the repo path is set up for worktrees
    if not args.repo_path.endswith(PROJECTS_SUFFIX) or \
       not os.path.isdir(f'{args.repo_path}/{BARE_FOLDER}'):
        print('Git repo path is not set up for worktrees:', args.repo_path)
        return

    if args.add:
        add_worktree(args.repo_path, args.branch_name)
    elif args.delete:
        remove_worktree(args.repo_path, args.branch_name)


# Create the main parser
parser = argparse.ArgumentParser(
    description='Manage local git repos and git worktrees')
# Optional arguments
parser.add_argument(
    '-p', '--projects-path',
    default=PROJECTS_PATH,
    help='Path to the projects directory'
)

# Create subparsers for the different commands
# Create plant sub command parser
subparsers = parser.add_subparsers(
    dest='plant', help='Commands for managing local git repos and worktrees')
parser_plant = subparsers.add_parser(
    'plant', help='Clones a bare git repo and sets up worktrees'
)
parser_plant.add_argument('repo_url', help='URL of the git repo to clone')
parser_plant.set_defaults(func=plant)

# Create worktree sub command parser
parser_worktree = subparsers.add_parser(
    'worktree', help='Manages repo worktrees')
parser_worktree.add_argument(
    '-r', '--repo-path', help='Path to the git repo', default=parent_dir())
parser_worktree.add_argument(
    'branch_name',
    help='Name of the branch to switch to or create a new worktree for')
worktree_group = parser_worktree.add_mutually_exclusive_group(required=True)
worktree_group.add_argument(
    '-a', '--add', action='store_true', help='Add a new worktree')
worktree_group.add_argument(
    '-d', '--delete', action='store_true', help='Delete a worktree')
parser_worktree.set_defaults(func=worktree)

args = parser.parse_args()
args.func(args)
